{
  "hash": "847fb86c2c192bbe80c2cfb514c14ac7",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Practical IRT Modeling in brms\"\nauthor: \"Bertrand Wilden\"\ndate: \"2024-05-29\"\ncategories: [Bayes, Tutorial, brms]\nmax-description-length: 20\ndraft: true\nexecute: \n  message: false\n  warning: false\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(brms)\nlibrary(tidybayes)\nlibrary(ggplot2)\nlibrary(ggdist)\n```\n:::\n\n::: {.cell}\n<style type=\"text/css\">\n.title {\n  color: #f5f5f5;\n}\n</style>\n:::\n\n\n## A Conceptual Introduction to IRT\n\nItem-Response Theory (IRT) models are a class of models used to measure latent traits in individuals.[^1] These are characteristics which we cannot observe directly, such as height or weight, but instead have to infer indirectly through observed actions. For example, a student's responses to questions on an exam might give us some idea about their latent ability---or a politician's votes in Congress might give us some idea about their underlying political ideology.\n\n[^1]: IRT can also be used on non-individual units, such as organizations, but most examples use individual people.\n\nSay we want to estimate how left-wing or right-wing a Supreme Court justice is. We will call this ideology variable $\\theta$. One place is start would be to qualitatively code each Supreme Court decision as either being liberal (0) or conservative (1), and then look at the proportion of times each justice sided with the conservative outcome. Expressed as a statistical model we get:\n\n$$\n\\begin{aligned}\ny_{ij} \\sim \\text{Bernoulli}(\\Phi(\\theta_i))\n\\end{aligned}\n$$ {#eq-0pl}\n\nWhere whether each justice sides with a conservative decision ($y_{ij}$) is based probabilistically on the (scaled) proportion of conservative positions ($\\theta_i$). The Standard Normal cumulative distribution function ($\\Phi$) is there to add some random noise in the model. We don't want our ideology measurements to be deterministic based on past decisions. Instead, we want to allow some room for some idiosyncratic errors to occur. On even the most conservative possible decision, we allow for *some tiny* probability that Clarence Thomas sides with the liberals. The Bernoulli distribution turns the probabilities produced by the $\\Phi$ function into observed 0's and 1's (liberal or conservative votes). See my [post on Probit regression models](https://www.bwilden.com/posts/probit-probit/) for more on this.\n\nThe model in @eq-0pl has at least one major flaw. Because there are only parameters for justices ($\\theta_i$) and none for cases, it treats all cases before the Supreme Court as interchangeable. Additive indices such as these implicitly assume that each \"item\" (i.e. case) contributes the same amount of weight towards measuring the latent variable in question. In the example of the Supreme Court this is clearly a bad assumption to make since some cases clearly have more ideological importance than others.[^2]\n\n[^2]: The no-ideological-difference-among-items assumption is pretty much always wrong, yet researchers continue to use additive index scales of latent variables in the social sciences all time. Do better! It's not that hard!\n\n$$\n\\begin{aligned}\ny_{ij} \\sim \\text{Bernoulli}(\\Phi(\\theta_i + \\xi_j))\n\\end{aligned}\n$$ {#eq-1pl}\n\nLet's fix this flaw by adding a case-level parameter ($\\xi_j$) to the model. @eq-1pl is commonly known as the *1-Parameter IRT Model*.[^3] Each case now has an independent latent variable for how likely *every* justice is to vote in the conservative direction. In IRT models within the context of standardized tests, $\\xi$ is called the \"difficulty\" parameter---questions on exams vary in how difficult they are to answer correctly.\n\n[^3]: Which is confusing because there are two parameters in the model: $\\theta$ and $\\xi$. Note that $\\theta$ in @eq-1pl is not formulated exactly the same as the additive index $\\theta$ in @eq-0pl. In @eq-1pl $\\theta$ is simply an arbitrary parameter for the latent variable as opposed to the scaled proportion of conservative votes as in @eq-0pl. We can, however, still interpret larger values of $\\theta$ as more conservative and lower values of $\\theta$ as more liberal.\n\n$$\n\\begin{aligned}\ny_{ij} \\sim \\text{Bernoulli}(\\Phi(\\gamma_j\\theta_i + \\xi_j))\n\\end{aligned}\n$$ {#eq-2pl}\n\nThe 1-Parameter IRT model in @eq-1pl is a big improvement over the additive index model in @eq-0pl, but if we want to be serious about measuring Supreme Court justice ideology we need to go further. The *2-Parameter IRT model* in @eq-2pl adds one more case-level parameter ($\\gamma$) which allows the *ideological valence* of each case to vary. In the test-taking context, $\\gamma$ is referred to as the \"discrimination\" parameter. What this means in the context of the Supreme Court is that we expect certain cases to more strongly separate liberal justices from conservative justices.[^4]\n\n[^4]: A note on notation: in the dozens of books/articles I've read on IRT modeling, I have not found even two which share the same Greek letters for the ability, difficulty, and discrimination parameters. Sometimes $\\alpha$ is in place of $\\theta$. Sometimes $\\beta$ is in place of $\\xi$. The $\\gamma$ parameter can be any number of letters. I have decided to contribute to this ongoing mess and confusion by using my own $(\\gamma_j\\theta_i + \\xi_j)$, whose exact permutation I have not seen anywhere else. \n\n\n## Step-by-Step IRT Modeling in brms\n\nNow let's turn to coding up the IRT model in @eq-2pl, and using it to measure the ideology of Supreme Court justices. There are three steps to this process:\n\n1. Prepare the data\n2. Build the model\n3. Extract the ideology estimates\n\n### Step 1: Prepare the data\n\nThe Washington University Law [Supreme Court Database](http://scdb.wustl.edu/data.php) is a fantastic resource for data on Supreme Court cases. We will be using the justice centered data because ultimately it is justice characteristics we care about.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvotes <- readr::read_csv(here::here(\"posts\", \"irt-brms\", \"data-raw\", \"SCDB_2023_01_justiceCentered_Vote.csv\"))\n```\n:::\n\n\nThe `votes` data frame contains justice voting data stretching back to 1946. It is already in \"long format\", which is great because that's what works best with our modeling approach using the [brms R package](https://paul-buerkner.github.io/brms/). By long format we mean that every row contains a unique justice-case pair.[^5]\n\n[^5]: Long data is in contrast to \"wide\" data in a vote matrix---where the rows are justices and the columns are cases. Older IRT estimation packages, such as [pscl](https://github.com/atahk/pscl), prefer data in the form a vote matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvotes_recent <- votes |> \n  filter(term == 2022) |> \n  mutate(direction = case_when(direction == 2 ~ 1,\n                               direction == 1 ~ 2,\n                               .default = NA))\n```\n:::\n\n\nNext we will filter out all years except for the 2022 term because this is where the 6-3 vs 3-3-3 debate is taking place. Lastly, we will recode the outcome variable, `direction`, such that `2` represents the conservative position and `1` represents the liberal position. This helps align liberal with \"left-wing\" and conservative with \"right-wing\" on the ideology scale we are building. The method behind coding a decision as liberal versus conservative is explained in more detail [here](http://scdb.wustl.edu/documentation.php?var=decisionDirection).\n\n### Step 2: Build the model\n\n\n::: {.cell}\n\n```{.r .cell-code}\nirt_formula <- bf(\n  direction ~ gamma * theta + xi,\n  gamma ~ (1 | caseId),\n  theta ~ (1 | justiceName),\n  xi ~ (1 | caseId),\n  nl = TRUE\n)\n\nirt_priors <- \n  prior(normal(0, 2), class = b, nlpar = gamma, lb = 0) +\n  prior(normal(0, 2), class = b, nlpar = theta) +\n  prior(normal(0, 2), class = b, nlpar = xi)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nget_prior(\n  formula = irt_formula, \n  data = votes_recent, \n  family = bernoulli(link = \"probit\")\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nirt_fit <- brm(\n  formula = irt_formula,\n  prior = irt_priors,\n  data = votes_recent,\n  family = bernoulli(link = \"probit\"),\n  backend = \"cmdstanr\",\n  cores = 8,\n  threads = threading(2),\n  control = list(adapt_delta = 0.99,\n                 max_treedepth = 15),\n  refresh = 0,\n  seed = 111\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRunning MCMC with 4 chains, at most 8 in parallel, with 2 thread(s) per chain...\n\nChain 2 finished in 32.4 seconds.\nChain 4 finished in 33.3 seconds.\nChain 3 finished in 34.9 seconds.\nChain 1 finished in 57.1 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 39.4 seconds.\nTotal execution time: 57.2 seconds.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(irt_fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Family: bernoulli \n  Links: mu = probit \nFormula: direction ~ gamma * theta + xi \n         gamma ~ (1 | caseId)\n         theta ~ (1 | justiceName)\n         xi ~ (1 | caseId)\n   Data: votes_recent (Number of observations: 623) \n  Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\n         total post-warmup draws = 4000\n\nMultilevel Hyperparameters:\n~caseId (Number of levels: 55) \n                    Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsd(gamma_Intercept)     1.66      1.11     0.34     4.55 1.00      715     1102\nsd(xi_Intercept)        2.80      0.69     1.61     4.30 1.00      616     1205\n\n~justiceName (Number of levels: 9) \n                    Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsd(theta_Intercept)     1.45      1.12     0.35     4.29 1.00     1287     1751\n\nRegression Coefficients:\n                Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\ngamma_Intercept     1.09      0.71     0.20     2.96 1.00     1274     1513\ntheta_Intercept    -1.02      1.03    -3.24     0.93 1.01      337      538\nxi_Intercept        0.90      0.76    -0.77     2.27 1.01      261      626\n\nDraws were sampled using sample(hmc). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\njustice_draws <- irt_fit |> \n  spread_draws(r_justiceName__theta[justice,]) |> \n  ungroup() |> \n  mutate(justice = case_when(justice == \"SAAlito\" ~ \"Alito\",\n                             justice == \"CThomas\" ~ \"Thomas\",\n                             justice == \"NMGorsuch\" ~ \"Gorsuch\",\n                             justice == \"ACBarrett\" ~ \"Barrett\",\n                             justice == \"JGRoberts\" ~ \"Roberts\",\n                             justice == \"BMKavanaugh\" ~ \"Kavanaugh\",\n                             justice == \"KBJackson\" ~ \"Jackson\",\n                             justice == \"EKagan\" ~ \"Kagan\",\n                             justice == \"SSotomayor\" ~ \"Sotomayor\"),\n         theta = r_justiceName__theta,\n         justice = forcats::fct_reorder(justice, theta))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nget_variables(irt_fit)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\njustice_draws |> \n  ggplot(aes(x = theta, \n             y = justice)) +\n  stat_slabinterval(aes(fill_ramp = after_stat(x)),\n                    fill = \"green\",\n                    density = \"unbounded\",\n                    alpha = .75) +\n  scale_fill_ramp_continuous(from = \"blue\") +\n  xlim(c(-3.5, 3.5)) +\n  labs(x = \"Ideology\", y = \"\", title = \"2022 Term\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# ggsave(\"judge_ideolog.png\", bg = \"white\")\n```\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}